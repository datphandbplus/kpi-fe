import { EventEmitter, Component, forwardRef, NgZone, ElementRef, Input, Output, ViewChild, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

const defaults = {
    contentsCss: [''],
    customConfig: ''
};
class CKEditorComponent {
    constructor(ngZone, hostEl) {
        this.ngZone = ngZone;
        this.hostEl = hostEl;
        this.innerValue = '';
        this.disabled = false;
        this.editorInitialized = false;
        /**
         * Is readonly mode, default:false
         */
        this.readonly = false;
        /**
         * The ck-editor config object.
         */
        this.config = {};
        /**
         * The special skin, default: moono-lisa
         */
        this.skin = 'moono-lisa';
        /**
         * The special language, default: en
         */
        this.language = 'en';
        /**
         * Use fullpage mode, default:false
         */
        this.fullPage = false;
        /**
         * Use inline mode, default: false
         */
        this.inline = false;
        this.change = new EventEmitter();
        this.ready = new EventEmitter();
        this.blur = new EventEmitter();
        this.focus = new EventEmitter();
        this.onChange = (value) => { };
        this.onTouched = () => { };
        this.identifier = CKEditorComponent.getRandomIdentifier(this.id);
    }
    static getRandomIdentifier(id = '') {
        return 'editor-' + (id !== '' ? id : String(CKEditorComponent.idx++));
    }
    get instance() {
        return this.ckIns;
    }
    ngOnInit() { }
    ngOnChanges(changes) {
        if (this.editorInitialized) {
            this.destroyEditor();
            this.initEditor(this.identifier);
        }
    }
    ngAfterViewChecked() {
        if (!this.editorInitialized && this.documentContains(this.textareaRef.nativeElement)) {
            this.editorInitialized = true;
            this.initEditor(this.identifier);
        }
        else if (this.editorInitialized && !this.documentContains(this.textareaRef.nativeElement)) {
            this.editorInitialized = false;
            this.destroyEditor();
        }
    }
    ngOnDestroy() {
        this.destroyEditor();
    }
    initEditor(identifier) {
        if (typeof CKEDITOR === 'undefined') {
            return console.warn('CKEditor 4.x is missing (http://ckeditor.com/)');
        }
        const textareaEl = this.textareaRef.nativeElement;
        this.identifier = identifier;
        textareaEl.setAttribute('name', this.identifier);
        if (this.ckIns || !this.documentContains(this.textareaRef.nativeElement)) {
            return;
        }
        const opt = Object.assign({}, defaults, this.config, {
            readOnly: this.readonly,
            skin: this.skin,
            language: this.language,
            fullPage: this.fullPage,
            inline: this.inline
        });
        this.ckIns = this.inline ? CKEDITOR.inline(textareaEl, opt) : CKEDITOR.replace(textareaEl, opt);
        this.ckIns.setData(this.innerValue);
        this.ckIns.on('change', () => {
            const val = this.ckIns.getData();
            this.updateValue(val);
        });
        this.ckIns.on('instanceReady', (evt) => {
            this.ngZone.run(() => {
                this.ready.emit(evt);
            });
        });
        this.ckIns.on('blur', (evt) => {
            this.ngZone.run(() => {
                this.blur.emit(evt);
                this.onTouched();
            });
        });
        this.ckIns.on('focus', (evt) => {
            this.ngZone.run(() => {
                this.focus.emit(evt);
            });
        });
    }
    destroyEditor() {
        if (this.ckIns) {
            // If use destroy, will fire 'Error code: editor-destroy-iframe'
            // this.ckIns.destroy();
            if (CKEDITOR.instances.hasOwnProperty(this.ckIns.name)) {
                CKEDITOR.remove(CKEDITOR.instances[this.ckIns.name]);
            }
            this.ckIns = null;
            const editorEl = this.hostEl.nativeElement.querySelector('#cke_' + this.identifier);
            if (editorEl != null && editorEl.parentElement) {
                editorEl.parentElement.removeChild(editorEl);
            }
        }
    }
    updateValue(value) {
        this.ngZone.run(() => {
            this.innerValue = value;
            this.onChange(value);
            this.onTouched();
            this.change.emit(value);
        });
    }
    documentContains(node) {
        return document.contains ? document.contains(node) : document.body.contains(node);
    }
    writeValue(value) {
        this.innerValue = value || '';
        if (this.ckIns) {
            // Fix bug that can't emit change event when set non-html tag value twice in fullpage mode.
            this.ckIns.setData(this.innerValue);
            const val = this.ckIns.getData();
            this.ckIns.setData(val);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
CKEditorComponent.idx = 1;
CKEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ck-editor',
                template: `
    <textarea #textarea aria-label="editor content"></textarea>
  `,
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CKEditorComponent), multi: true }],
                exportAs: 'ckEditor'
            },] }
];
CKEditorComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef }
];
CKEditorComponent.propDecorators = {
    readonly: [{ type: Input }],
    config: [{ type: Input }],
    skin: [{ type: Input }],
    language: [{ type: Input }],
    fullPage: [{ type: Input }],
    inline: [{ type: Input }],
    id: [{ type: Input }],
    change: [{ type: Output }],
    ready: [{ type: Output }],
    blur: [{ type: Output }],
    focus: [{ type: Output }],
    textareaRef: [{ type: ViewChild, args: ['textarea', { static: false },] }]
};

class CKEditorModule {
}
CKEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [FormsModule, CKEditorComponent],
                declarations: [CKEditorComponent],
                providers: []
            },] }
];

/*
 * Public API Surface of ngx-ckeditor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CKEditorComponent, CKEditorModule };
//# sourceMappingURL=ngx-ckeditor.js.map
